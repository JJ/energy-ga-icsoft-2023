<!doctype html>
<html lang="en">
    <head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Wivace 2023: Energy analysis JS VMs</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
        <link rel="stylesheet" href="dist/extra.css">
	<link rel="stylesheet" href="dist/icsoft.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
    </head>
    <body>
	<div class="reveal">
	    <div class="slides">
		<section data-background=""><h1>Energy consumption of evolutionary algorithms in JavaScript</h1>

                    <h2>Merelo (UGR-ES), Garc√≠a-Valdez (ITT-MX), Castillo
                        (UGR-ES)</h2>
                    <h3>Wivace, 2023</h3>
                </section>
		<section data-background=""><h1>Green
                    computing</h1>
                    <h2>Minimize the amount of energy spent in algorithms/applications</h2>
                </section>

                <section data-background="">
                    <h1>No fixed set of rules for "greening"</h1>
                    <h2 class="fragment">Algorithm/language specific experimental methodology</h2>
                </section>

                <section
                data-background=""><h1>JavaScript
                    is here to stay</h1>
                    <h2 class="fragment">ECMA standard</h2>
                    <h2 class="fragment">And has different interpreters:
                        <code>bun</code>, <code>deno</code>,
                        <code>node.js</code></h2>

                    <aside class="notes">It's overall a pretty good deal, very popular and good for your career. It shouldn't be left aside for GAs. At any rate, we can generalize this methodology to any language that has different VMs (like Java) or compilers (like C or C++, with different open source compilers).</aside>
                </section>

                <section data-background=""><h1>Using RAPL for energy profiling</h1>
                    <h2 class="fragment">Intel-defined machine readable machine
                        registers</h2>
                    <h2 class="fragment">PKG == CORE + RAM</h2>
                    <aside class="notes">PKG is the name of the register, and
                    the one we are going to use here. These registers also
                    appear in other architectures, mainly AMD (not ARM or Mac),
                        but they are emulated and not all features are
                    used. This is the first phase: choosing sensors</aside>
                </section>

                <section data-background=""> <h1>Using command-line tools that measure single
                    processes</h1>
                    <h2 class="fragment">Measure 15 times, take average, measure
                        energy consumption of <code>sleep</code> during that
                        time</h2>
                    <h3 class="fragment">Not ideal but roughly accurate</h3>
                    <aside class="notes">Really, they measure everything during
                        said process</aside>
                </section>


                <section>
                    <section data-background=""><h1>Fitness, mutation and crossover, most important
                        operations</h1>
                        <h2 class="fragment">Involves integer arithmetic +
                            list/string manipulation</h2>

                        <aside class="notes">So we're measuring with pinpoint,
                    subtracting the "background consumption", and repeating
                            measures 15 times. </aside>
                    </section>

		    <section><h1>So far:</h1>
		      <h3>Measurements March 2023, published July 2023</h3>
		      <h2 class='fragment'><code>bun</code> rocks</h2>
		      <h2 class='fragment'><code>pinpoint</code>, best tool for command-line measures</h2>
		    </section>

		    <section><h1>What we'll be doing now</h1>
		      <h2 class='fragment'>Is there any change with new runtime versions?</h2>
		      <h2 class='fragment'>Is mutation also a significant operator?</h2>
		      <h2 class='fragment'>What happens with different hardware architectures?</h2>
		    </section>

                    <section><h1>OneMax: code</h1>
                        <pre><code data-line-numbers="8|9">/**
 *
 * @param {String} A chromosome of zeros and ones
 * @returns {Number} number of ones
 */
export function countOnes(chromosome) {
  return chromosome
    .split("")
    .reduce((acc, bit) => acc + (bit === "1" ? 1 : 0), 0);
}
                        </code></pre>
                        <aside class="notes">We have made a certain number of
                        choices regarding the representation, as well as the
                        functions uses. Reduce functions are usually faster,
                        although since we're using strings we need to split on
                        its components. Also, JS is strongly typed, so we need
                            to transform to add.</aside>
                    </section>

                    <section><h1>Onemax: Energy vs. time</h1>
                        <img src="img/fig1-onemax-PKG-vs-seconds.png" alt="PKG
                                  vs. seconds" height="800">
                        <aside class="notes">We can see how there's an increase
                        with size, but it's not linear; at any rate, we can also
                            see how little energy (and time) bun takes to run this workload</aside>
                    </section>

                    <section><h1>Onemax: Energy vs. size</h1>
                        <img src="img/fig2-onemax-PKG-vs-size.png" alt="PKG
                                  vs. size" height="800">
                        <aside class="notes">Bun is consistently the best, saving almost 80% of energy with respect to the mainstream node.</aside>
                    </section>

		    <section><h1>Crossover</h1>
		      <pre><code data-line-numbers="5,6|7-12">export function crossover(chrom1, chrom2) {
  const length = chrom1.length;
  const xover_point = 1 + Math.floor(Math.random() * (length - 1));
  const range = 1 + Math.floor(Math.random() * (length - xover_point));
  let new_chrom1 = chrom1.substring(0, xover_point);
  let new_chrom2 = chrom2.substring(0, xover_point);
  new_chrom1 +=
    chrom2.substring(xover_point, xover_point + range) +
    chrom1.substring(xover_point + range, length);
  new_chrom2 +=
    chrom1.substring(xover_point, xover_point + range) +
    chrom2.substring(xover_point + range, length);
  return [new_chrom1, new_chrom2];
}		      </code></pre>
		    </section>

		    <section><h1>Crossover: Energy vs. time</h1>
                        <img src="img/fig3-over-PKG-vs-seconds.png" alt="PKG
                                  vs. seconds" height="800">
                        <aside class="notes">We should note that this energy is
                        around 40% less than for onemax; that is, it's taking a
                        considerable amount of energy, but individually it takes
                        less. However, in the case of benchmarking fitness it's
                        going to be in the same order of magnitude. </aside>
                    </section>

		        <section><h1>Crossover: Energy vs. time</h1>
                        <img src="img/fig4-over-PKG-vs-size.png" alt="PKG
                                  vs. size" height="800">
                        <aside class="notes">As in the case of Onemax, there is
                        a strange behavior in the deno interpreter, that takes
                        less energy (even if takes more time) for the bigger size.</aside>
                    </section>

                </section>

		<section data-background=""><h1>Conclusions</h1>
            
		</section>

                <section data-background=""><h1>Vi ringrazio per la vostra atenzione</h1></section>

	    </div>
	</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
			    hash: true,
                            width: "95%",
			    height: '100%',
			    controls: true,
			    progress: true,
			    backgroundTransition: 'convex',
			    // Learn about plugins: https://revealjs.com/plugins/
			    plugins: [ RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
