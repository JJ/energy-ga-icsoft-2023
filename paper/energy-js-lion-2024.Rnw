\documentclass[runningheads]{llncs}

\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}

\newcommand{\pinp}{\texttt{pinpoint}}
\newcommand{\lik}{\texttt{likwid}}

\begin{document}

\title{How evolutionary algorithms consume energy depending on the language and its level}

\author{
  Juan J. Merelo-Guervós\inst{1}\orcidID{0000-0002-1385-9741}
and
  Mario García-Valdez\inst{2}\orcidID{0000-0002-2593-1114}
}
\institute{Department of Computer Engineering, Automatics and Robotics, University of Granada, Granada, Spain \and
Department of Graduate Studies, National Technological Institute of Mexico, Tijuana, Mexico\\
\email{jmerelo@ugr.es, mario@tectijuana.edu.mx}
}


\maketitle

\begin{abstract}
Making evolutionary algorithms greener imply tackling implementation issues from different angles. Practitioners need to focus on those that can be more easily leveraged, such as the choice of the language that is going to be used; high level (interpreted), mid-level (based on multi-platform virtual machines) and low-level (native) languages will need power in different ways, and choosing one or the other will have an impact on energy consumption. We will be looking at the implementation of key evolutionary algorithm functions, in three languages at three different levels: the high-level JavaScript, the mid-level Kotlin, which runs on the Java Virtual Machine, and the low level Zig. Looking beyond the obvious, as the lower the level, the less energy consumption should be expected, we will try to have a more holistic view of the implementation of the algorithms in order to  extract best practices regarding its green implementation. 
\keywords{Green computing, metaheuristics, JavaScript, energy-aware computing, evolutionary algorithms, zig, Kotlin}
\end{abstract}

\section{\uppercase{Introduction}}
\label{sec:introduction}

The interest in greener computing has grown in the last decades, in part fueled by the Objectives of the Millenium that advocate for a lower carbon footprint in human activity, and in part due to the fact that performance improvements brought by faster hardware are not coming with the same speed as they used to. There are many different ways to approach this problem, however: as Hidalgo et al. affirm \cite{hidalgo2023sustainable}, there are four different levels for the evaluation and eventual improvement of energy consumption in AI (including, as in this paper, metaheuristics): just above the hardware level there is the programming language level, which includes not only the language itself, but also libraries and compilers or interpreters. This was the topic of \cite{DBLP:conf/icsoft/GuervosGC23}, where our focus was to work on different JavaScript interpreters in order to discover which one used system energy more efficiently.

However, there are many user cases in which the language used by all or part of the metaheuristic can also be chosen. A simple choice of language will impact greatly energy consumption, as shown in \cite{PEREIRA2021102609}. In \cite{DBLP:conf/iwann/MereloRACML11} we looked at the performance of different languages when implementing an evolutionary algorithm; in this paper we will focus on the language level, before delving into specific language characteristics. We will work with a high level language, JavaScript, using the fastest implementation available, {\sf bun}, a mid-level language, Kotlin, that compiles to bytecode of the Java virtual machine (JVM) and a low-level language, Zig, a relatively new language that is still not reached production, but is however used for {\sf bun} itself. All these languages have toolchains that are free software, and thus can be used without any kind of limitation.

As in previous papers, we will focus on two critical evolutionary algorithm functions \cite{abdelhafez2019component}: the  fitness function, as well as {\em genetic} operators. However, we will use a heavier fitness function in this case: Hierarchical If and only IF (HIFF) \cite{watson1998modeling} for independent measurement, as well as combine mutation and crossover, the simpler OneMax function and 2-tournament selection together for a combined measurement of the effect of these operators together, along with the operations (such as comparison) they need.


\section{Methodology}
\label{sec:meth}
In this paper we will factor out the time needed to generate the chromosomes; this is usually a one-shot in evolutionary algorithms and not very significant in evolutionary algorithm workloads, and it will allow us to focus on the added energy consumption of the operations themselves.

<<lion.setup, echo=F, message=F>>=
library(dplyr)
generate.chromosomes.bun <- read.csv("../data/pinpoint-v2-chromosome_generation-12-Dec-17-24-44.csv")
generate.chromosomes.bun  %>% group_by( size ) %>% summarise( mean.pkg = mean( PKG ), mean.seconds = mean( seconds ) ) -> generate.chromosomes.bun.avg

generate.chromosomes.zig <- read.csv("../data/pinpoint-zig-9-Feb-12-35-59.csv")
generate.chromosomes.zig %>% group_by( size ) %>% summarise( mean.pkg = mean( PKG ), mean.seconds = mean( seconds ) ) -> generate.chromosomes.zig.avg

generate.chromosomes.kotlin <- read.csv("../data/pinpoint-kotlin-9-Feb-17-36-57.csv")
generate.chromosomes.kotlin %>% group_by( size ) %>% summarise( mean.pkg = mean( PKG ), mean.seconds = mean( seconds ) ) -> generate.chromosomes.kotlin.avg
@


<<lion.hiff.bun, echo=F, message=F>>=

hiff.bun <- read.csv("../data/pinpoint-v3-HIFF-13-Dec-09-06-34.csv")
hiff.bun %>% mutate( delta.pkg = PKG - generate.chromosomes.bun.avg$mean.pkg[ match( size, generate.chromosomes.bun.avg$size ) ], delta.seconds = seconds - generate.chromosomes.bun.avg$mean.seconds[ match( size, generate.chromosomes.bun.avg$size ) ] ) -> hiff.bun.delta

generation.bun <- read.csv("../data/pinpoint-v3-generation-13-Dec-10-10-00.csv")
generation.bun %>% mutate( delta.pkg = PKG - generate.chromosomes.bun.avg$mean.pkg[ match( size, generate.chromosomes.bun.avg$size ) ], delta.seconds = seconds - generate.chromosomes.bun.avg$mean.seconds[ match( size, generate.chromosomes.bun.avg$size ) ] ) -> generation.bun.delta

@

%\section*{Acknowledgements}

%This work is supported by the Ministerio espa\~{n}ol de Econom\'{\i}a y
%Competitividad (Spanish Ministry of Competitivity and Economy) under project
%PID2020-115570GB-C22 (DemocratAI::UGR).

\bibliographystyle{splncs04}

\bibliography{energy,javascript,geneura}


\end{document}

