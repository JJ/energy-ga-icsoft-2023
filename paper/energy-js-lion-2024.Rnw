\documentclass[runningheads]{llncs}

\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}

\newcommand{\pinp}{\texttt{pinpoint}}
\newcommand{\lik}{\texttt{likwid}}

\begin{document}

\title{How evolutionary algorithms consume energy depending on the level language}

\author{
  Juan J. Merelo-Guervós\inst{1}\orcidID{0000-0002-1385-9741}
and
  Mario García-Valdez\inst{2}\orcidID{0000-0002-2593-1114}
}
\institute{Department of Computer Engineering, Automatics and Robotics, University of Granada, Granada, Spain \and
Department of Graduate Studies, National Technological Institute of Mexico, Tijuana, Mexico\\
\email{jmerelo@ugr.es, mario@tectijuana.edu.mx}
}


\maketitle

\begin{abstract}
Making evolutionary algorithms greener imply working with attacking implementation from different angles. An interesting one is looking at how high level (interpreted), mid-level (based on multi-platform virtual machines) and low-level (native) will impact energy consumption. We will be looking at the implementation of key evolutionary algorithm functions, in three languages: JavaScript, Kotlin and Zig, to extract best practices regarding green implementation of evolutionary algorithms.
\keywords{Green computing, metaheuristics, JavaScript, energy-aware computing, evolutionary algorithms, zig, Kotlin}
\end{abstract}

\section{\uppercase{Introduction}}
\label{sec:introduction}

The interest in greener computing has grown in the last decades, in part fueled by the Objectives of the Millenium that advocate for a lower carbon footprint in human activity, and in part due to the fact that performance improvements brought by faster hardware are not coming with the same speed as they used to. There are many different ways to approach this problem, however: as Hidalgo et al. affirm \cite{hidalgo2023sustainable}, there are four different levels for the evaluation and eventual improvement of energy consumption in AI (including, as in this paper, metaheuristics): just above the hardware level there is the programming language level, which includes not only the language itself, but also libraries and compilers or interpreters. This was the topic of \cite{DBLP:conf/icsoft/GuervosGC23}, where our focus was to work on different JavaScript interpreters in order to discover which one used system energy more efficiently.

However, there are many user cases in which the language used by all or part of the metaheuristic can also be chosen. A simple choice of language will impact greatly energy consumption, as shown in \cite{PEREIRA2021102609}. In \cite{DBLP:conf/iwann/MereloRACML11} we looked at the performance of different languages when implementing an evolutionary algorithm; in this paper we will focus on the language level, before delving into specific language characteristics. We will work with a high level language, JavaScript, using the fastest implementation available, {\sf bun}, a mid-level language, Kotlin, that compiles to bytecode of the Java virtual machine (JVM) and a low-level language, Zig, a relatively new language that is still not reached production, but is however used for {\sf bun} itself.

As in previous papers, we will focus on two critical evolutionary algorithm functions \cite{abdelhafez2019component}: the OneMax fitness function, as well as the crossover operator. In this paper we will try to factor out the time needed to generate the chromosomes; this is usually a one-shot in evolutionary algorithms and not very significant; however factoring it out will allow us to focus on the added energy consumption of the operations themselves.


%\section*{Acknowledgements}

%This work is supported by the Ministerio espa\~{n}ol de Econom\'{\i}a y
%Competitividad (Spanish Ministry of Competitivity and Economy) under project
%PID2020-115570GB-C22 (DemocratAI::UGR).

\bibliographystyle{splncs04}

\bibliography{energy,javascript,geneura}


\end{document}

