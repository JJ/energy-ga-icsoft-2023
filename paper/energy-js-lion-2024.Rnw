\documentclass[runningheads]{llncs}

\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}

\newcommand{\pinp}{\texttt{pinpoint}}
\newcommand{\lik}{\texttt{likwid}}

\begin{document}

\title{How evolutionary algorithms consume energy depending on the language and its level}

\author{
  Juan J. Merelo-Guervós\inst{1}\orcidID{0000-0002-1385-9741}
and
  Mario García-Valdez\inst{2}\orcidID{0000-0002-2593-1114}
}
\institute{Department of Computer Engineering, Automatics and Robotics, University of Granada, Granada, Spain \and
Department of Graduate Studies, National Technological Institute of Mexico, Tijuana, Mexico\\
\email{jmerelo@ugr.es, mario@tectijuana.edu.mx}
}


\maketitle

\begin{abstract}
Making evolutionary algorithms greener imply tackling implementation issues from different angles. Practitioners need to focus on those that can be more easily leveraged, such as the choice of the language that is going to be used; high level (interpreted), mid-level (based on multi-platform virtual machines) and low-level (native) languages will need power in different ways, and choosing one or the other will have an impact on energy consumption. We will be looking at the implementation of key evolutionary algorithm functions, in three languages at three different levels: the high-level JavaScript, the mid-level Kotlin, which runs on the Java Virtual Machine, and the low level Zig. Looking beyond the obvious, as the lower the level, the less energy consumption should be expected, we will try to have a more holistic view of the implementation of the algorithms in order to  extract best practices regarding its green implementation.
\keywords{Green computing, metaheuristics, JavaScript, energy-aware computing, evolutionary algorithms, zig, Kotlin}
\end{abstract}

\section{\uppercase{Introduction}}
\label{sec:introduction}

The interest in greener computing has grown in the last decades, in part fueled by the Millenium Development Goals \cite{world2004millennium} that advocate for a lower carbon footprint in human activity, and in part due to the fact that performance improvements brought by faster hardware are not coming with the same speed as they used to \cite{theis2017end}. There are many different ways to approach this problem, however: as Hidalgo et al. affirm \cite{hidalgo2023sustainable}, there are four different levels for the evaluation and eventual improvement of energy consumption in AI (including, as in this paper, metaheuristics): just above the hardware level there is the programming language level, which includes not only the language itself, but also libraries and compilers or interpreters. This was the topic of \cite{DBLP:conf/icsoft/GuervosGC23}, where our focus was to work on different JavaScript interpreters in order to discover which one used system energy more efficiently.

However, there are many user cases in which the language used by all or part of the metaheuristic can also be chosen. A simple choice of language will impact greatly energy consumption, as shown in \cite{PEREIRA2021102609}. In \cite{DBLP:conf/iwann/MereloRACML11} we looked at the performance of different languages when implementing an evolutionary algorithm; in this paper we will focus on the language level, before delving into specific language characteristics. We will work with a high level language, JavaScript, using the fastest implementation available, {\sf bun}, a mid-level language, Kotlin, that compiles to bytecode of the Java virtual machine (JVM) and a low-level language, Zig, a relatively new language that is still not reached production, but is however used for {\sf bun} itself. All these languages have toolchains that are free software, and thus can be used without any kind of limitation.

These languages can also be divided along two different axes:\begin{itemize}
\item Memory management: it is done automatically in high-level languages, like JavaScript and Kotlin, while it involves a series of choices in the case of Zig.
\item Compilation: JavaScript is interpreted, Kotlin is compiled to bytecode and then interpreted by the JVM, and Zig is compiled to native code, but this implies also what happens with optimization: high-level languages take all decisions, while Zig will allow you to choose between different optimization levels; it also means that a different kind of overhead will be incurred when running a program: JavaScript will load the interpreter in memory, and then parse and run the program; Kotlin will actually use the Java virtual machine to run, and it will be loaded and then the bytecode parsed and run; finally, Zig creates executables, which will have some overhead due to standard linked libraries.
\end{itemize}

Making comparisons of energy spent by different implementations needs, first, a methodology to make choices that are comparable across all three platforms; then what exactly is going to be measured needs to be established, and how to make those measurements so that they make differences stand out. As in previous papers, we will focus on two critical evolutionary algorithm functions \cite{abdelhafez2019component}: the  fitness function, as well as {\em genetic} operators. However, we will use a heavier fitness function in this case: Hierarchical If and only IF (HIFF) \cite{watson1998modeling} for independent measurement, as well as combine mutation and crossover, the simpler OneMax function and 2-tournament selection together for a combined measurement of the effect of these operators together, along with the operations (such as comparison) they need.

The rest of the paper is organized as follows: next we present the state of the art in software engineering and its analysis of energy consumption of different software platforms, to be followed by the methodology we are going to apply in this paper, mainly concerned with evolutionary algorithms in \ref{sec:meth}. Then we will present the results of the experiments in \ref{sec:results}, and finally we will discuss the results and draw some conclusions in \ref{sec:conclusions}.

\section{State of the art}
\label{sec:soa}

The shade of green of different languages has been repeatedly examined in the literature, at least since it actually became a concern in software engineering \cite{pinto2017energy}, very recently, indeed, this concern has been systematized in what are called the GREENER principles \cite{lannelongue2023greener}.

\section{Methodology}
\label{sec:meth}

In this paper we will factor out the time needed to generate the chromosomes; this is usually a one-shot in evolutionary algorithms and not very significant in evolutionary algorithm workloads, and it will allow us to focus on the added energy consumption of the operations themselves.

<<lion.setup, echo=F, message=F>>=
library(dplyr)
generate.chromosomes.bun <- read.csv("../data/generate-chromosomes-bun-lion-24.csv")
generate.chromosomes.bun  %>% group_by( size ) %>% summarise( mean.pkg = mean( PKG ), mean.seconds = mean( seconds ) ) -> generate.chromosomes.bun.avg

generate.chromosomes.zig <- read.csv("../data/generate-chromosomes-zig-lion-24.csv")
generate.chromosomes.zig %>% group_by( size ) %>% summarise( mean.pkg = mean( PKG ), mean.seconds = mean( seconds ) ) -> generate.chromosomes.zig.avg

generate.chromosomes.kotlin <- read.csv("../data/generate-chromosomes-kotlin-lion-24.csv")
generate.chromosomes.kotlin %>% group_by( size ) %>% summarise( mean.pkg = mean( PKG ), mean.seconds = mean( seconds ) ) -> generate.chromosomes.kotlin.avg
@


<<lion.hiff.bun, echo=F, message=F>>=

hiff.bun <- read.csv("../data/pinpoint-v3-HIFF-13-Dec-09-06-34.csv")
hiff.bun %>% mutate( delta.pkg = PKG - generate.chromosomes.bun.avg$mean.pkg[ match( size, generate.chromosomes.bun.avg$size ) ], delta.seconds = seconds - generate.chromosomes.bun.avg$mean.seconds[ match( size, generate.chromosomes.bun.avg$size ) ] ) -> hiff.bun.delta

generation.bun <- read.csv("../data/pinpoint-v3-generation-13-Dec-10-10-00.csv")
generation.bun %>% mutate( delta.pkg = PKG - generate.chromosomes.bun.avg$mean.pkg[ match( size, generate.chromosomes.bun.avg$size ) ], delta.seconds = seconds - generate.chromosomes.bun.avg$mean.seconds[ match( size, generate.chromosomes.bun.avg$size ) ] ) -> generation.bun.delta

@

\section{Results}
\label{sec:results}

\section{Discussion, conclusion and future work}
\label{sec:conclusions}

\section*{Acknowledgements}

This work is supported by the Ministerio espa\~{n}ol de Econom\'{\i}a y
Competitividad (Spanish Ministry of Competitivity and Economy) under project
PID2020-115570GB-C22 (DemocratAI::UGR).

\bibliographystyle{splncs04}

\bibliography{energy,javascript,geneura}


\end{document}

