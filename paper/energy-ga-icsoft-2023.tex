\documentclass[a4paper,twoside]{article}

\usepackage{epsfig}
\usepackage{subcaption}
\usepackage{calc}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{multicol}
\usepackage{pslatex}
\usepackage{apalike}
\usepackage[bottom]{footmisc}
\usepackage{SCITEPRESS}     % Please add other packages that you may need BEFORE the SCITEPRESS.sty package.
\usepackage{hyperref}

\begin{document}

\title{An analysis of energy consumption of JavaScript interpreters/compilers in evolutionary algorithm workloads}

\author{\authorname{Juan J. Merelo-Guervós\sup{1}\orcidAuthor{0000-0002-1385-9741} and Mario García-Valdez\sup{2}\orcidAuthor{0000-0002-2593-1114}}
\affiliation{\sup{1}Department of Computer Engineering, Automatics and Robotics, University of Granada, Granada, Spain}
\affiliation{\sup{2}Department of Graduate Studies, National Technological Institute of Mexico, Tijuana, Mexico}
\email{jmerelo@ugr.es, mario@tectijuana.edu.mx}
}

\keywords{Green computing, metaheuristics, JavaScript}

\abstract{
% The abstract should summarize the contents of the paper and should contain at least 70 and at most 200 words. The text must be set to 9-point font size.
}

\onecolumn \maketitle \normalsize \setcounter{footnote}{0} \vfill

\section{\uppercase{Introduction}}
\label{sec:introduction}

% About popularity the TIOBE index is more complete, there JS ranks in 7h. - M
% Added - JJ
% We could explain a bit about the ogrady ranking, that is based on github
% repos. - M
% Done - JJ


From a language designed in the nineties for simple browser widgets and
client-side validations \cite{goodman2007javascript,flanagan1998javascript},
JavaScript is nowadays the language most widely used by developers in their
GitHub repositories \cite{ogrady22:ranking}, occupying this position since 2014
\cite{ogrady14:ranking}, mainly because it is almost exclusively the language
needed for front-end programming (competing only with app development languages,
such as Swift or Kotlin, or languages transpiled to JavaScript, such as Dart),
while at the same time being strong for full-stack development, with solid
support for the back end, including application servers, middleware, and
database programming. Other popularity indices, such as
TIOBE\footnote{\url{https://www.tiobe.com/tiobe-index/}}, that take into account other
factors besides lines of code production, currently (2023) rank it as the seventh,
although it was also the most popular language in 2014. It can
be claimed, then, that it is among the most popular, if not the most popular
language in current development.

Due to its popularity and the fact that it has a
continuously evolving standard \cite{ecma1999262}, traditionally, there have
been different virtual machines (or interpreters) to run its programs. During
the first years, browsers were the only running platform available; however, the
introduction of Node.js running on the V8 JavaScript Engine \cite{5617064} gave
it the popularity it has today; this popularity, in turn, provoked new
interpreters to spawn like {\sf deno} \cite{runtimeintroducing} (written in
Rust) and {\sf bun} \cite{bun} programmed in the relatively unknown language
Zig.

No wonder, then, that JavaScript is also a popular language for implementing
metaheuristics, especially evolutionary algorithms, since early implementations
in the browser \cite{smith1996ga,jesusIWANN99,langdon2004global}, whole
libraries \cite{EvoStar2014:jsEO}, through complete implementations geared
towards volunteer computing \cite{2016arXiv160101607M}. But one of the
criticisms leveraged towards these implementations of evolutionary algorithms
is the (possible) lack of speed of the language compared to other compiled
languages (mainly Java, very popular with metaheuristics implementations, or
C++).

This is why, since implementation matters \cite{DBLP:conf/iwann/MereloRACML11},
choosing the right interpreter is going to have a big impact on the performance
of any workload; if you decide to choose JavaScript for any reason (such as
seamless client/server integration, or be able to run your algorithm either on
the browser or from the command line if desired) knowing which VM delivers the
best performance is essential, either from the scientific point of view, or
from the software engineering point of view.

At the same time, with the advent of the concept of green computing
\cite{kurp2008green}, it becomes increasingly important to measure not only the
raw wall clock performance (which was the focus of papers such as
\cite{DBLP:conf/evoW/GuervosBCRGRVHR17}), but also to achieve a certain level
of performance with a certain amount of energy consumption, or else to minimize
the consumption needed to run a certain workload. This will be the main focus
of this paper; since the core of the different JS virtual machines is
different, and are created with languages with different focus (Rust is focused
on memory safety \cite{noseda2022rust}, Zig based on simplicity and performance
\cite{zig}), different consumption should be expected. Since all three
languages can (roughly) run the same, unmodified source code, what we intend
with this paper is to advise on which JS interpreter might give the lowest
power consumption, the maximum performance, or both, so that evolutionary
algorithm practitioners can target it for their development.

The rest of the paper follows this plan: next we will present the state of the
art; then we will describe the experimental setup in Section \ref{sec:setup};
results will be presented next in Section \ref{sec:res}, and we will end with a
discussion of results, conclusions and future lines of work.

\section{State of the art}

% First, CPU and general algorithmic impact on power consumption

The power efficiency of CPUs (computations per kilowatt-hour) has doubled
roughly every year and a half from 1946 to 2009 \cite{koomey2011web}, this
improvement has been mainly a by-product of Moore's law, the trend of chip
manufacturers to decrease in half the size and distance between transistors
every two years. Unfortunately, it is expected that physical limits of
electronics will slow down this miniaturization in the near future.
Nonetheless, energy efficiency is becoming the most important metric of
performance and selling point in hardware development, and it is an important
driver for current innovation. The challenge of building more power-efficient
systems, can be addressed at the hardware and software levels. In the software
level, developers focus their attention on the energy consumption of software,
proposing optimizations for more energy-efficient algorithm implementations.
Algorithm comparatives nowadays include power efficiency as a performance metric,
these include encryption algorithms
\cite{mota2017comparative,thakor2021lightweight}, and estimation models for
machine learning applications \cite{garcia2019estimation} and genetic
programming (GP) \cite{diaz2018fuzzy}. Since metaheuristics are so extensively
used in machine learning applications, its interest in research has grown in
parallel to its number of applications. Many papers focus on analyzing how
certain metaheuristics parameters have an impact on energy consumption.
Díaz-Álvarez et al. \cite{diaz2022population} studies how the populations size
of evolutionary algorithms (EAs) influences power consumption. In genetic algorithms (GAs), the
mutation operator appears to be a power-hungry component according to
Abdelhafez et al. \cite{abdelhafez2019component}, in their paper they also
report that in a distributed evaluation setting, the communication scheme has a
grater impact. Fernández de Vega et al. \cite{10.1007/978-3-319-45823-6_51}
experimented with different parameters for a GP algorithm and concluded that
hand-held devices and single-board computers (SBCs) required an order of
magnitude less energy to run the same algorithm. 


\section{Methodology and experimental setup}
\label{sec:setup}

There are many ways to measure the consumption of applications running in a
computer; besides measuring directly from the power intake, those running as
applications and tapping the computer sensors fall roughly into two fields:
power monitors and energy profilers \cite{cruz21}. Power monitors need
additional hardware to measure the actual power drawn by the whole machine;
besides being expensive, they have a difficult set-up, as well as being
complicated to measure exactly what a specific process is consuming.

On the other hand, energy profilers are programs that draw information from
hardware sensors \cite{sinha2001jouletrack}, generally exposed through kernel
calls or higher level wrapper libraries, to pinpoint consumption during a period
of time of by specific processes. Tools that give these measures either with a
graphic or a command line interface have been available for some time already,
and lately become more popular. One of the mainstream processor architectures,
Intel, includes an interface called RAPL, or Running Average Power Limit
\cite{rapl}. Essentially, it consists of a series of machine-specific registers
(MSRs) that contain information on wattage drawn by different parts of the
architecture; the content of these registers will be processed (through the
corresponding library) and consumed by different command line utilities. We will
use these command line utilities, since they produce an output that can be
automatically processed and evaluated, which is what we are looking for in this
paper\footnote{Systems based on the AMD architecture have a similar power
  profiling architecture called AMP with its corresponding command line
  tool. However, it was not well documented, and we found it excessively
  complicated for the purposes of this article. Although not as complete, AMD
  processors also include the aforementioned MSRs so RAPL-based utilities can
  run on them}.

Energy profiling, as measured by RAPL or other APIs, includes different
\emph{domains} \cite{khan2015energy}, essentially computing devices or
peripherals that are actually requiring the reported amount of energy. DRAM or
dynamic RAM, CORE, or GPU will report what happens on those specific devices,
with a core being every one of the computing units within the central processing
unit; other domains, like PKG or package, will report what happens in the
``package'', or CPU together with other devices in the chipset.

Taking into account that the available system has an AMD architecture, which is
roughly compatible with the RAPL architecture, we will use two command line
utilities, as they are the only ones available that can wrap the execution of a command
and report on consumption for that specific command. These are open source tools
that can be obtained directly from the corresponding repositories, or by downloading and
compiling its source code. \begin{itemize}
\item {\sf pinpoint}~\cite{9307947} (available from
  \url{https://github.com/osmhpi/pinpoint}) is a tool that uses the RAPL
  interface, as well as the NVIDIA registers, to report the power consumed by
  these devices. In this paper, we will use it since it is the only one out of
  the three tools that can show the GPU consumption.
\item {\sf
    perf}\footnote{\url{https://perf.wiki.kernel.org/index.php/Main_Page}}~\cite{treibig2010likwid} is a
  system tool that measures all kinds of performance events, including power
  consumption. It will be used mainly for the  \texttt{pkg} domain; this is a
  domain that it is measured by all tools, but all of them would process device
    readings differently, so it will provide us with alternative estimations of
    the consumption. % it will provide (the domain? of the tools?)
    % The tool will provide a different estimation from the MSR reading; this is
    % what I understood, at least. - JJ
\item {\sf likwid-powermeter}\footnote{\url{https://github.com/RRZE-HPC/likwid}}
  measures the \texttt{CORE} as well as the \texttt{PKG} domain, which includes
  the former together with the so-called ``uncore'' components.
  
\end{itemize}

\section{Experimental results}
\label{sec:res}

\section{Conclusions}
\label{sec:conc}

\section*{Acknowledgements}

This work is supported by the Ministerio espa\~{n}ol de Econom\'{\i}a y
Competitividad (Spanish Ministry of Competitivity and Economy) under project
PID2020-115570GB-C22 (DemocratAI::UGR).


\bibliographystyle{apalike}
{\small
\bibliography{energy,javascript,geneura}}


\end{document}

