\documentclass[runningheads]{llncs}

\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}

\newcommand{\pinp}{\texttt{pinpoint}}
\newcommand{\lik}{\texttt{likwid}}

\begin{document}
\title{Best practices for energy-thrifty evolutionary algorithms in the low-level language {\sf zig}}

\author{
  Juan J. Merelo-Guervós\inst{1}\orcidID{0000-0002-1385-9741} \and Antonio M. Mora\inst{2}\orcidID{0000-0003-1603-9105} \and Mario García-Valdez\inst{3}\orcidID{0000-0002-2593-1114}
}
\institute{Department of Computer Engineering, Automatics and Robotics and CITIC University of Granada, Granada, Spain \and 
Department of Signal Theory, Telematics and Communications, University of Granada, Granada, Spain \and
Department of Graduate Studies, National Technological Institute of Mexico, Tijuana, Mexico\\
\email{jmerelo@ugr.es, amorag@ugr.es, mario@tectijuana.edu.mx}
}

\maketitle

\begin{abstract}
The most fruitful way of making evolutionary algorithms spend the least amount of energy is to consider all possible programming techniques that could, theoretically, affect performance, and carry out experiments using EA workloads in different platforms, eventually choosing those techniques that yield the minimum amount of energy expenses. These techniques include choice of different data structures, as well as affecting compilation in such a way that energy footprint is reduced; they have to be replicated in different computing platforms, because these expenditures may be affected by all the layers of the operating system and runtime framework used. In this paper we will experiment with different data structures and code refactoring techniques in the low-level language {\sf zig}, trying to come up with rules of thumb that will help developers create {\em green} evolutionary algorithms.
\keywords{Green computing, metaheuristics, energy-aware computing, evolutionary algorithms, zig}
\end{abstract}

A straightforward methodology for measuring energy consumption of EA implementations with the objective of reducing it would consider a baseline implementation, and then change the code at different levels, measuring the resulting energy expenses. In \cite{DBLP:conf/icsoft/GuervosGC23} the main factor under study was the different interpreters used in a high-level language, JavaScript. In this paper we will focus on different techniques applied to the low-level language {\sf zig}, a language that emphasizes safety and maintainability \cite{friesen2023designing}, and that has as a motto "no implicit memory allocation", unlike other languages like C or C++, that will allocate memory without the user noticing. This strict memory management has several implications in terms of programming, but also gives the programmer more control over when memory is allocated and deallocated.

In this paper we will work on a generic evolutionary algorithm workload, and see what the impact of different choices will have on its energy consumption. With this, we will try to find some best practices that will help practitioners implement evolutionary algorithms in {\sf zig}, hopefully extensible to other low-level languages (which could include C and C++, but also Rust or Go).

The experiment setup will match the one used in \cite{DBLP:conf/icsoft/GuervosGC23}, using the same tools for energy profiling ({\sf pinpoint}) as well as Perl scripts to run the experiments and process the results.
The experiments for this paper will be carried out in two different platforms:\begin{itemize} 
\item A Linux machine {\tt 5.15.0-94-generic \#104~20.04.1-Ubuntu SMP} using AMD Ryzen 9 3950X 16-Core Processor.
\item a MacBook Air M1 with 16GB of RAM and macOS Ventura 13.2.1.
\end{itemize}

We use {\sf zig}  version 0.11.0, released by August 3, 2023, which is the last stable one at the time of writing this paper. The {\sf pinpoint} tool has no versions, but we have used one compiled from source and commit hash {\tt 1578db0}. Outputs of {\sf pinpoint} are processed by Perl scripts, that generate CSV files that are then processed and plotted using R embedded in the source code of this paper. All code, data and source for this paper are available at \url{https://github.com/JJ/energy-ga-icsoft2023} under a free license.

There are several units whose consumption can be measured using {\sf pinpoint} via the RAPL interface; since the use of GPU is negligible in these examples, only memory and CPUs will be measured. Together, they are called the {\em package} (alongside with caches and memory controllers); this is usually represented by the acronym {\sf PKG}. In the case of the Mac, this measurement is divided in three parts: the "E" (efficiency) and "P" (performance) CPUs, and the memory. Again, these user-initiated processes run on the "P" CPUs, so that will be the one we will be measuring.

By default, all programs will be generated using the {\tt .ReleaseFast} compile option, that optimizes performance, but also energy consumption. We will be using the {\tt page\_allocator} that allocates memory in the heap. This is an efficient allocator, but also the default choice.

We will be examining options in different areas\begin{itemize}
\item Several type of data structures will be checked for: the default string, arrays of Boolean values and bit sets.
\item The default crossover operator used an allocator to create temporary copies of chromosomes. It will be refactored so that no allocation is necessary.
\item Unlike other languages, {\sf zig} provides different memory allocators, which can be chosen by the developer. By default, a page allocator is used, but there is the possibility of using a fixed buffer size allocator.
\item We will check the behavior of these in two different platforms, Linux (with AMD) and Mac (with M1).
\end{itemize}

We will first generate 40000 chromosomes of size 512, 1024 and 2048, and measure the energy consumption and running time of this operation; every combination is run 15 times. 

<<evostar.zig.gen, echo=F, message=F, fig.pos="h!tb", fig.height=3, fig.cap="Average running time and PKG energy consumption generating 40K chromosomes for the different parametrizations used (represented with different colors); dot shape represents the chromosome size.">>=
library(dplyr)
library(ggplot2)

generate.chromosomes <- read.csv("../data/evostar-zig-gen-19-Mar-09-31-21.csv")
generate.chromosomes$size <- as.factor(generate.chromosomes$size)

generate.chromosomes.bool <- read.csv("../data/evostar-zig-gen-bool-19-Mar-09-30-40.csv")
generate.chromosomes.bool$size <- as.factor(generate.chromosomes.bool$size)

generate.chromosomes.bitset <- read.csv("../data/evostar-zig-bitset-gen-20-Mar-12-18-47.csv")
generate.chromosomes.bitset$size <- as.factor(generate.chromosomes.bitset$size)

generate.chromosomes.mac <- read.csv("../data/evostar-mac-gen-19-Mar-11-05-41.csv")
generate.chromosomes.mac$PKG <- generate.chromosomes.mac$ECPU + generate.chromosomes.mac$PCPU + generate.chromosomes.mac$RAM
generate.chromosomes.mac$size <- as.factor(generate.chromosomes.mac$size)

generate.chromosomes.mac.bool <- read.csv("../data/evostar-mac-gen-bool-19-Mar-10-33-29.csv")
generate.chromosomes.mac.bool$PKG <- generate.chromosomes.mac.bool$ECPU + generate.chromosomes.mac.bool$PCPU + generate.chromosomes.mac.bool$RAM
generate.chromosomes.mac.bool$size <- as.factor(generate.chromosomes.mac.bool$size)


ggplot(generate.chromosomes, aes(x=seconds, y=PKG, color="Baseline", shape=size)) +
  geom_point() +
  geom_point(data=generate.chromosomes.bitset, aes(x=seconds, y=PKG, color="BitSet", shape=size)) +
  geom_point(data=generate.chromosomes.bool, aes(x=seconds, y=PKG, color="Boolean", shape=size)) +
  geom_point(data=generate.chromosomes.mac, aes(x=seconds, y=PKG, color="Mac Baseline", shape=size)) +
  geom_point(data=generate.chromosomes.mac.bool, aes(x=seconds, y=PKG, color="Mac Boolean", shape=size)) +
  scale_color_manual(values=c("black", "red", "blue", "green","pink")) +
  labs(title="Running time and PKG energy consumption generating 40K chromosomes",
       x="Running time", y="PKG (Joules)") +
  theme_minimal()
@

Figure \ref{fig:evostar.zig.gen} represents energy consumption, as well as time taken, for the different configurations taken as baseline. The first thing to notice, in the upper right corner, is that using a bitset in zig will not represent any energy saving, with a big difference in time as well as energy consumption; this is why it has not been even tested for the Mac. Second element that stands out is that consumption as well as time is very different for the Mac, which is a baseline laptop computer, and the AMD desktop computer. This is probably expected, but the fact is that the Mac Air, which is a generation behind current commercial offerings, takes 25\% of the time and 10\% of the energy to do the exact same amount of work. While the increase in energy consumption is quite steep in the AMD architecture the desktop computer uses, that is not the case for the Mac, with a very small increase from the smallest to the largest size.

Another observation is that, except for using bitsets as data structures, there does not seem to be a significant difference between using either strings or Boolean arrays in neither architecture, at least for this baseline operation. However, generating chromosomes is done essentially once, so it is not the most significant operation in EAs.

Thus, we will now run an experiment that, after generating the 40K chromosomes, will perform crossover + mutation + onemax operations on chromosomes of size 512, 1024 and 2048 using the strings and Boolean arrays in the two architectures used above.

<<lion.zig.combined.ops, echo=F, message=F, fig.pos="h!tb", fig.height=3, fig.cap="Boxplot of PKG energy consumption processing 40K chromosomes via crossover, mutation and ONEMAX for different combinations of optimization techniques in Zig">>=

@

This case is remarkably different to the one shown in Figure \ref{fig:lion.zig.setup}. For starters, the energy consumption is very low, one order of magnitude lower; regular genetic operations do not spend a lot of energy indeed, with most consumption focused on fitness functions. Even so, the fast compilation spends half the energy of the other combinations. Remarkably, using a different data structure does not always imply a better energy profile; it does so only for the smaller size, 512 bits (which is anyway closer to usual chromosome sizes).

In this paper we have used different techniques that potentially could reduce the amount of energy spent by a genetic algorithm implemented using the low-level language {\sf zig}: testing different data structures, allocation policies and compilation options. The most dramatic reduction is achieved with the {\em fast} compilation policy, but additional improvements can be obtained by using adequate data structures and allocation policies. By using best practices in this area, {\sf zig} implementations can indeed be considered the {\em greener} ones among other high-level or Java Virtual Machine based languages. it remains as future work, however, how applying similar techniques when available will impact the energy consumption of other languages.


\section*{Acknowledgements and data availability}

This work is supported by the Ministerio espa\~{n}ol de Econom\'{\i}a y
Competitividad (Spanish Ministry of Competitivity and Economy) under project
PID2020-115570GB-C22 (DemocratAI::UGR). We are also very grateful to the {\sf zig} community. Source and data available from \url{https://github.com/JJ/energy-ga-icsoft-2023} under a GPL license.

\bibliographystyle{splncs04}

\bibliography{energy,javascript,geneura}


\end{document}

